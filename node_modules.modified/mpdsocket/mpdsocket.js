var net = require('net');
var sys = require('sys');

function mpdSocket(host,port) {
    if (!host) this.host = "localhost";
    if (!port) this.port = 6600;

    this.open(host,port);
}

mpdSocket.prototype = {
    callbacks: [],
    isOpen: false,
    socket: null,
    version: undefined,
    buffer: '',
    lines: [],

    bufferData: function(data) {
	this.buffer += data;
        var pos = 0;
	var i;
	while ((i = this.buffer.indexOf('\n', pos)) > -1) {
	    var line = this.buffer.substr(pos, i-pos);
	    this.handleLine.call(this, line);
	    pos = i+1;  // the +1 skips the \n
	}
	if (pos < this.buffer.length) {
	    // incomplete line, save it for the next round
	    this.buffer = this.buffer.substr(pos);
	} else {
	    this.buffer = '';
	}
    },

    handleLine: function(line) {
	if (!this.version && line.match(/^OK MPD /)) {
            this.version = line.split(' ')[2];
	    //console.log('mpd protocol version ' + this.version);
   	    return;
	}
	this.lines.push(line);
        if (line.match(/^OK$|^ACK \[/)) {
            this.handleLines.call(this, this.lines);
            this.lines = [];
	}
    },

    handleLines: function(lines) {
        var response = [new Object];
        for (var i in lines) {
            var line = lines[i];
            if (line.match(/^OK$|^ACK \[/)) {
		break;
            } else {
                var colon = line.indexOf(':');
                var attr = line.substr(0,colon);
                var value = line.substr(colon+1);
                value = value.replace(/^\s+|\s+$/g, ''); // trim whitespace
                if (typeof(response[response.length-1][attr]) !== 'undefined') {
                    response.push(new Object);
                }
                response[response.length-1][attr] = value;
            }
        }
	// the next three lines convert a single entry to not be in a 1 item list
        //if (response.length === 1) {
        //  response = response[0];
        //}
	response._verbatim = line;
        response._OK = (line === 'OK');
	if (!response._OK) {
	    console.log(line);
	    if (line) {
		response._error = line.substr(line.indexOf('}') +2);
	    }
	}
        return this.callbacks.shift()(response);
    },

    on: function(event, fn) {
        this.socket.on(event,fn);
    },

    open: function(host,port) {
        var self = this;
        if (!(this.isOpen)) {
						if (host.indexOf('/') === 0) {
								// support unix domain sockets
								this.socket = net.createConnection(host);
						} else {
								this.socket = net.createConnection(port,host);
						}
            this.socket.setEncoding('UTF-8');
            this.socket.addListener('connect',function() { self.isOpen = true; });
            this.socket.addListener('data',function(data) { self.bufferData.call(self,data); });
            this.socket.addListener('end',function() { self.isOpen = false; });
        }
    },

    send: function(req,callback) {
        if (this.isOpen) {
            this.callbacks.push(callback);
            this.socket.write(req + "\n");
        } else {
            throw "mpdNotOpenException";
        }
    }
}

module.exports = mpdSocket;
